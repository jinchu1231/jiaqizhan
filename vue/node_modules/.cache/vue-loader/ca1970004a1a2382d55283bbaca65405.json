{"remainingRequest":"/Users/交安/gas/vue/gas-web/node_modules/_vue-loader@15.11.1@vue-loader/lib/index.js??vue-loader-options!/Users/交安/gas/vue/gas-web/src/components/VisualPortal/HMapChart/index.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/交安/gas/vue/gas-web/src/components/VisualPortal/HMapChart/index.vue","mtime":1706684850000},{"path":"/Users/交安/gas/vue/gas-web/node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/交安/gas/vue/gas-web/node_modules/_babel-loader@8.3.0@babel-loader/lib/index.js","mtime":456789000000},{"path":"/Users/交安/gas/vue/gas-web/node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/交安/gas/vue/gas-web/node_modules/_vue-loader@15.11.1@vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport { getMapData, getAtlas } from '@/api/onlineDev/portal'\nimport CardHeader from \"../CardHeader\"\nimport { getDataInterfaceRes } from '@/api/systemData/dataInterface'\nimport resize from '@/components/Charts/mixins/resize'\nimport { mapChartData } from '@/components/VisualPortal/PortalDesign/components/data'\nimport { debounce } from 'throttle-debounce'\nexport default {\n  mixins: [resize],\n  components: { CardHeader },\n  props: {\n    activeData: { type: Object, default: () => { } },\n  },\n  data() {\n    return {\n      isEmpty: false,\n      chart: null,\n      currOption: {},\n      currMapCode: null,\n      geoJson: null,\n      allAtlasList: [],\n      chartData: [],\n      mapData: [],\n      timeTicket: null,\n      count: 0,\n      hashMap: new Map(),\n      zoom: 1,\n      showBarTitle: false,\n      code: \"\",\n      updateMapChart: debounce(200, function () {\n        this.resetChart()\n      }),\n      updateBarChart: debounce(200, function () {\n        this.setBarMapChart()\n      })\n    }\n  },\n  computed: {\n    option() {\n      return this.activeData.option\n    },\n    jnpfKey() {\n      return this.activeData.jnpfKey\n    }\n  },\n  watch: {\n    'option': {\n      handler() {\n        this.clearHashMap()\n        this.updateMapChart()\n      },\n      deep: true\n    },\n    'option.defaultValue': {\n      handler(val) {\n        setTimeout(() => {\n          this.chartData = val\n          this.resetChart()\n        }, 0);\n      },\n    },\n    'option.updateMapType': {\n      handler(val) {\n        const code = Array.isArray(this.option.mapType) ? this.option.mapType[this.option.mapType.length - 1] : this.option.mapType\n        if (this.currMapCode != code) this.initMap()\n      }\n    },\n    'activeData.dataType': {\n      handler(val) {\n        this.option.defaultValue = []\n        this.chartData = []\n        if (val == 'static') this.option.defaultValue = mapChartData\n      }\n    },\n    'activeData.propsApi': {\n      handler(val) {\n        if (this.activeData.dataType === 'static' || !val) return\n        getDataInterfaceRes(val).then(res => {\n          this.chartData = res.data\n          this.resetChart()\n        })\n      },\n    },\n  },\n  mounted() {\n    if (this.activeData.dataType === 'dynamic') {\n      if (!this.activeData.propsApi) return\n      getDataInterfaceRes(this.activeData.propsApi).then(res => {\n        this.chartData = res.data\n        this.initMap()\n      })\n    } else {\n      setTimeout(() => {\n        this.chartData = this.option.defaultValue\n        this.initMap()\n      }, 0);\n    }\n    this.$eventBus.$on('eChart' + this.activeData.i, () => {\n      this.$nextTick(() => {\n        this.resize()\n        this.$nextTick(() => {\n          this.setBarMapChart()\n        })\n      })\n    })\n    this.getAtlasList()\n  },\n  methods: {\n    initMap() {\n      const code = Array.isArray(this.option.mapType) ? this.option.mapType[this.option.mapType.length - 1] : this.option.mapType\n      if (!code) return\n      this.chart && this.chart.dispose()\n      this.chart = null\n      this.chart = echarts.init(this.$refs.chart)\n      this.chart.showLoading();\n      this.currMapCode = code\n      getMapData(code).then(res => {\n        this.chart.hideLoading();\n        this.geoJson = res.data\n        this.code = code\n        this.initCurrOption()\n        echarts.registerMap(code, this.geoJson);\n        this.chart.setOption(this.currOption, true)\n        this.setScatterMapChart()\n        this.setBarMapChart()\n        if (this.option.autoCarousel) this.handleDispatchAction()\n        this.clearHashMap()\n        this.chart.on('click', (param) => {\n          if (!this.option.drillDown) return\n          if (!this.allAtlasList.length) return\n          const item = this.allAtlasList.find((i) => i.fullName === param.name)\n          if (item) {\n            if (this.currMapCode == item.enCode) return\n            this.currMapCode = item.enCode\n            getMapData(item.enCode).then(res => {\n              this.code = item.enCode\n              this.initCurrOption()\n              echarts.registerMap(item.enCode, res.data);\n              this.chart.setOption(this.currOption, true)\n              this.setScatterMapChart()\n              this.setBarMapChart()\n              this.zoom += 1\n              this.setHashMap(param.name, item.enCode, res.data)\n            })\n          }\n        });\n        this.chart.on('mouseover', (params) => {\n          if (!this.option.autoCarousel) return\n          clearInterval(this.timeTicket);\n          this.chart.dispatchAction({\n            type: 'showTip',\n            seriesIndex: 0,\n            dataIndex: params.dataIndex,\n          });\n        });\n        this.chart.on('mouseout', () => {\n          if (this.option.autoCarousel) this.handleDispatchAction()\n        });\n        this.chart.on('georoam', () => {\n          this.updateBarChart()\n        });\n      })\n    },\n    resetChart() {\n      if (!this.geoJson) return\n      this.isEmpty = JSON.stringify(this.currOption) === \"{}\"\n      if (!this.isEmpty) {\n        this.initCurrOption()\n        echarts.registerMap(this.code, this.geoJson);\n        this.chart.setOption(this.currOption, true)\n        this.setScatterMapChart()\n        this.setBarMapChart()\n        if (this.option.autoCarousel) this.handleDispatchAction()\n      }\n    },\n    initCurrOption() {\n      const option = this.option\n      let title = {\n        text: option.titleText,\n        textStyle: {\n          color: option.titleTextStyleColor,\n          fontSize: option.titleTextStyleFontSize,\n          fontWeight: option.titleTextStyleFontWeight ? 'bolder' : '',\n        },\n        subtext: option.titleSubtext,\n        subtextStyle: {\n          color: option.titleSubtextStyleColor,\n          fontSize: option.titleSubtextStyleFontSize,\n          fontWeight: option.titleSubtextStyleFontWeight ? 'bolder' : '',\n        },\n        left: option.titleLeft,\n        backgroundColor: option.titleText || option.titleSubtext ? option.titleBgColor || '#fff' : '#fff',\n      }\n      let tooltip = {\n        show: this.option.tooltipShow,\n        backgroundColor: this.option.tooltipBgColor,\n        textStyle: {\n          color: this.option.tooltipTextStyleColor,\n          fontSize: this.option.tooltipTextStyleFontSize,\n          fontWeight: this.option.tooltipTextStyleFontWeight ? 'bolder' : '',\n        },\n      }\n      let geo = {\n        id: \"china\",\n        map: this.code,\n        show: true,\n        roam: option.geoRoam,\n        aspectScale: option.geoAspectScale || 0.75,\n        layoutCenter: [option.seriesCenterLeft + '%', option.seriesCenterTop + '%'],\n        layoutSize: '85%',\n        itemStyle: {\n          areaColor: option.geoAreaColor,\n          borderWidth: option.geoBorderWidth / 2,\n          borderColor: option.geoBorderColor,\n          shadowOffsetX: option.geoShadowOffset,\n          shadowOffsetY: option.geoShadowOffset,\n          shadowColor: option.geoShadowColor,\n        },\n        zoom: option.mspScale,\n        label: {\n          show: option.geoLabelShow,\n          color: option.geoLabelColor,\n          fontWeight: option.geoLabelFontWeight ? 'bolder' : 'normal',\n          fontSize: option.geoLabelFontSize,\n        },\n      }\n      let visualMap = {\n        min: option.visualMapMin,\n        max: option.visualMapMax,\n        type: option.visualMapType,\n        showLabel: true,\n        realtime: false,\n        calculable: true,\n        inRange: {\n          color: ['#3BD9FF', '#0246FF']\n        }\n      }\n      this.currOption = {\n        title: title,\n        tooltip: tooltip,\n        geo: geo,\n        visualMap: visualMap,\n      }\n    },\n    setScatterMapChart() {\n      const option = this.option\n      if (option.styleType == 3) return\n      this.mapData = []\n      if (this.chartData && this.chartData.length) {\n        this.chartData.map(ele => {\n          const coord = this.chart.convertToPixel('geo', [ele.long, ele.lat]) || []\n          const flag = this.chart.containPixel('geo', coord)\n          if (flag) this.mapData.push({ name: ele.name, value: [ele.long, ele.lat, ele.value] })\n        })\n      }\n      if (option.showNumber == null) {\n        this.mapData = this.mapData\n      } else {\n        this.mapData = this.mapData.slice(0, option.showNumber)\n      }\n      this.currOption.series = [\n        {\n          type: option.styleType == 1 || option.styleType == 4 ? option.seriesType : 'heatmap',\n          rippleEffect: {\n            brushType: 'stroke'\n          },\n          coordinateSystem: \"geo\",\n          itemStyle: {\n            color: \"#1890FF\",\n            opacity: option.seriesItemStyleOpacity\n          },\n          pointSize: option.seriesPointSize,\n          blurSize: option.seriesBlurSize,\n          maxOpacity: option.seriesMaxOpacity,\n          tooltip: {\n            show: true,\n            formatter: function (params) {\n              if (params.value.length < 3) return params.name\n              let str = params.name + '&nbsp&nbsp' + params.value[2]\n              return str\n            },\n          },\n          symbolSize: (val) => {\n            if (this.option.visualMapMax) {\n              let num = Number(this.option.visualMapMax)\n              let num1 = Number(val[2])\n              let res = num1 / num * 15\n              return res\n            }\n            return 10\n          },\n          clip: true,\n          data: this.mapData\n        }\n      ]\n      this.setBarRankMapChart()\n      this.chart.setOption(this.currOption)\n      if (this.timeTicket) clearInterval(this.timeTicket);\n    },\n    setBarMapChart() {\n      if (this.option.styleType != 3) return\n      const data = this.option.defaultValue\n      if (data && data.length) {\n        data.map((ele, idx) => {\n          if (!ele.long || !ele.lat) return\n          var coord = this.chart.convertToPixel('geo', [ele.long, ele.lat]) || [];\n          const flag = this.chart.containPixel('geo', coord)\n          if (!flag) return\n          var curOption = {\n            xAxis: [],\n            yAxis: [],\n            grid: [],\n            series: [],\n            tooltip: {\n              trigger: 'item',\n              axisPointer: {\n                type: 'none'\n              },\n            }\n          };\n          curOption.xAxis.push({\n            id: idx,\n            gridId: idx,\n            show: false,\n            splitLine: {\n              show: false\n            },\n            axisTick: {\n              show: false\n            },\n            axisLabel: {\n              show: false\n            },\n            data: [ele.name],\n            z: 100\n          });\n          curOption.yAxis.push({\n            id: idx,\n            gridId: idx,\n            show: false,\n            splitLine: {\n              show: false\n            },\n            axisTick: {\n              show: false\n            },\n            axisLabel: {\n              show: false\n            },\n            z: 100\n          });\n          // 配置柱状图绘制大小、位置\n          curOption.grid.push(\n            {\n              id: idx,\n              width: this.option.seriesBarWidth,\n              height: 70,\n              left: coord && coord[0],\n              top: coord && coord[1] - 70,\n              z: 100\n            });\n          // 生成柱状图数据\n          curOption.series.push({\n            id: idx,\n            type: 'bar',\n            xAxisId: idx,\n            yAxisId: idx,\n            barGap: 0,\n            barCategoryGap: 0,\n            data: [ele.value],\n            z: 100,\n            itemStyle: {\n              normal: {\n                borderRadius: this.option.seriesItemStyleBarBorderRadius,\n                label: {\n                  show: true,\n                  position: 'insideBottom',\n                  textStyle: {\n                    color: '#fff',\n                    fontSize: 10\n                  },\n                },\n              }\n            }\n          });\n          this.chart.setOption(curOption);\n        })\n      }\n    },\n    setBarRankMapChart() {\n      const option = this.option\n      if (option.styleType != 4) return\n      let myData = [['value', 'name']];\n      let mapData = JSON.parse(JSON.stringify(this.chartData))\n      if (option.showNumber) {\n        mapData = mapData.slice(0, option.showNumber)\n      }\n      var barData = mapData.sort(function (a, b) {\n        return b.value - a.value;\n      });\n      for (var i = 0; i < barData.length; i++) {\n        const ele = barData[i]\n        myData.push([ele.value, ele.name]);\n      }\n      this.currOption.grid = {\n        right: option.berGridRight,\n        top: option.berGridTop,\n        bottom: option.berGridBottom,\n        width: '200',\n      }\n      this.currOption.xAxis = {\n        name: 'value',\n        show: false,\n      }\n      this.currOption.yAxis = {\n        type: 'category',\n        inverse: true,\n        nameGap: 16,\n        axisLine: {\n          show: false,\n          lineStyle: {\n            color: '#303133'\n          }\n        },\n        axisTick: {\n          show: false,\n        },\n        axisLabel: {\n          interval: 0,\n          margin: 10,\n          textStyle: {\n            fontSize: 14\n          },\n        },\n      }\n      let series =\n      {\n        name: '柱状图',\n        type: 'bar',\n        roam: false,\n        zlevel: 2,\n        barGap: 0,\n        encode: {\n          x: 'value',\n          y: 'name'\n        },\n        label: {\n          normal: {\n            show: true,\n            position: 'right',\n            textBorderWidth: 0\n          }\n        },\n        itemStyle: {\n          normal: {\n            borderRadius: 2,\n          }\n        }\n      }\n      this.currOption.dataset = {\n        source: myData\n      }\n      this.currOption.visualMap.dimension = 0\n      this.currOption.series.push(series)\n      this.showBarTitle = true\n    },\n    setHashMap(name, value, geoJson) {\n      this.hashMap.set(1, this.getDefaultHashMap())\n      this.hashMap.set(this.zoom, {\n        name: name,\n        value: value,\n        geoJson: geoJson\n      })\n      this.hashMap.forEach((value, key, mapObj) => {\n        if (key > this.zoom) this.hashMap.delete(key)\n      })\n      this.hashMap.delete(this.zoom + 1)\n      this.hashMap = new Map(this.hashMap)\n    },\n    clearHashMap() {\n      this.hashMap.clear()\n      this.hashMap.set(1, { name: '中国', value: '10000', geoJson: this.geoJson })\n      this.hashMap = new Map(this.hashMap)\n    },\n    getDefaultHashMap() {\n      const code = Array.isArray(this.option.mapType) ? this.option.mapType[this.option.mapType.length - 1] : this.option.mapType\n      const item = this.allAtlasList.find((i) => i.enCode === code)\n      if (item) return { name: item.fullName, value: item.id, geoJson: this.geoJson }\n      return { name: '中国', value: '10000', geoJson: this.geoJson }\n    },\n    readyMap(key, { name, value, geoJson }) {\n      if (value == this.currMapCode) return\n      this.code = value\n      this.currMapCode = ''\n      if (key == 1) {\n        this.geoJson ? this.resetChart() : this.initMap()\n        this.clearHashMap()\n      } else {\n        this.initCurrOption()\n        echarts.registerMap(value, geoJson);\n        this.chart.setOption(this.currOption, true)\n        this.zoom = key\n        this.setHashMap(name, value, geoJson)\n      }\n    },\n    handleDispatchAction() {\n      clearInterval(this.timeTicket);\n      this.timeTicket = setInterval(() => {\n        let total = this.mapData.length\n        let curr = this.count % total;\n        this.chart.dispatchAction({\n          type: 'showTip',\n          seriesIndex: 0,\n          dataIndex: curr\n        });\n        this.count += 1;\n      }, this.option.autoCarouselTime || 3000);\n    },\n    getAtlasList() {\n      this.allAtlasList = []\n      getAtlas().then(res => {\n        const loop = (data) => {\n          if (Array.isArray(data)) {\n            for (let i = 0; i < data.length; i++) {\n              const ele = data[i];\n              this.allAtlasList.push(ele)\n              if (ele.children && ele.children.length) loop(ele.children)\n            }\n          }\n        }\n        loop(res.data)\n      })\n    }\n  }\n}\n",null]}