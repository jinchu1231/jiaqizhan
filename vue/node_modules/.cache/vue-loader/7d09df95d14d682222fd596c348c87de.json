{"remainingRequest":"/Users/交安/gas/vue/gas-web/node_modules/_vue-loader@15.11.1@vue-loader/lib/index.js??vue-loader-options!/Users/交安/gas/vue/gas-web/src/components/Process/FlowCard/Preview.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/交安/gas/vue/gas-web/src/components/Process/FlowCard/Preview.vue","mtime":1706684850000},{"path":"/Users/交安/gas/vue/gas-web/node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/交安/gas/vue/gas-web/node_modules/_babel-loader@8.3.0@babel-loader/lib/index.js","mtime":456789000000},{"path":"/Users/交安/gas/vue/gas-web/node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/交安/gas/vue/gas-web/node_modules/_vue-loader@15.11.1@vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\nimport { NodeUtils } from \"./util.js\";\nconst isCondition = data => data.type === \"condition\" || (data.type === \"approver\" && (data.isInterflow || data.isBranchFlow));\nconst notEmptyArray = arr => Array.isArray(arr) && arr.length > 0;\nconst hasBranch = data => notEmptyArray(data.conditionNodes);\nconst stopPro = ev => ev.stopPropagation();\n\nfunction createNormalCard(ctx, conf, h) {\n  let classList = ['flow-path-card']\n  if (conf.state) classList.push(conf.state)\n  const afterTrue = (isTrue, name) => (isTrue && classList.push(name), isTrue)\n  const isStartNode = afterTrue(NodeUtils.isStartNode(conf), 'start-node')\n  const isApprNode = afterTrue(NodeUtils.isApproverNode(conf), 'approver')\n  const isCopyNode = afterTrue(NodeUtils.isCopyNode(conf), 'copy')\n  const isTimerNode = afterTrue(NodeUtils.isTimerNode(conf), 'timer')\n  const isSubFlowNode = afterTrue(NodeUtils.isSubFlowNode(conf), 'subFlow')\n  return (\n    <section class={classList.join(' ')} onClick={this.eventLauncher.bind(ctx, \"edit\", conf)} >\n      <header class=\"header\">\n        <div class=\"title-box\" style=\"height: 100%;width:190px;\">\n          <span class=\"title-text\">{conf.properties.title}</span>\n        </div>\n        {(isSubFlowNode) && (\n          <el-tag class=\"async-state\" size=\"mini\" effect=\"plain\" style=\"right:10px\">{conf.properties.isAsync ? '异步' : '同步'}</el-tag>\n        )}\n      </header>\n      <div class=\"body\">\n        <span class=\"text\">{conf.content}</span>\n      </div>\n    </section>\n  );\n}\n// arg = ctx, data, h\nconst createFunc = (...arg) => createNormalCard.call(arg[0], ...arg)\nlet nodes = {\n  start: createFunc,\n  approver: createFunc,\n  copy: createFunc,\n  timer: createFunc,\n  subFlow: createFunc,\n  interflow: createFunc,\n  branchFlow: createFunc,\n  empty: _ => '',\n  condition: function (ctx, conf, h) {\n    return (\n      <section class=\"flow-path-card condition\">\n        <header class=\"header\">\n          <div class=\"title-box\" style=\"height: 20px;width:160px;\">\n            <span class=\"title-text\">{conf.properties.title}</span>\n          </div>\n        </header>\n        <div class=\"body\">\n          <div class=\"text\">{conf.content}</div>\n        </div>\n      </section>\n    );\n  }\n};\n\nfunction addNodeButton(ctx, data, h, isBranch = false) {\n  // 只有非条件节点和条件分支树下面的那个按钮 才能添加新分支树\n  let couldAddBranch = !hasBranch(data) || isBranch;\n  let isEmpty = data.type === \"empty\";\n  if (isEmpty && !isBranch) {\n    return \"\";\n  }\n  return (\n    <div class=\"add-node-btn-box flex justify-center\"></div>\n  );\n}\n\nfunction NodeFactory(ctx, data, h) {\n  if (!data) return\n  const showErrorTip = ctx.verifyMode && NodeUtils.checkNode(data) === false\n  let res = [],\n    branchNode = \"\",\n    selfNode = (\n      <div class=\"node-wrap\">\n        <div class={`node-wrap-box ${data.type} ${NodeUtils.isInterflowNode(data) ? 'interflow' : ''} ${NodeUtils.isBranchFlowNode(data) ? 'branchFlow' : ''} ${showErrorTip ? 'error' : ''}`}>\n          {nodes[data.type].call(ctx, ctx, data, h)}\n          {addNodeButton.call(ctx, ctx, data, h)}\n        </div>\n      </div>\n    );\n\n  if (hasBranch(data)) {\n    // 如果节点是数组 一定为条件分支 添加分支样式包裹\n    // {data.childNode && NodeFactory.call(ctx, ctx, data.childNode, h)}\n    branchNode = (\n      <div class=\"branch-wrap\">\n        <div class=\"branch-box-wrap\">\n          <div class=\"branch-box flex justify-center relative\">\n            <span class=\"line\"></span>\n            {data.conditionNodes.map(d => NodeFactory.call(ctx, ctx, d, h))}\n          </div>\n        </div>\n        {addNodeButton.call(ctx, ctx, data, h, true)}\n      </div>\n    );\n  }\n\n  if (isCondition(data)) {\n    return (\n      <div class=\"col-box\">\n        <div class=\"center-line\"></div>\n        <div class=\"top-cover-line\"></div>\n        <div class=\"bottom-cover-line\"></div>\n        {selfNode}\n        {branchNode}\n        {NodeFactory.call(ctx, ctx, data.childNode, h)}\n      </div>\n    );\n  }\n  res.push(selfNode);\n  branchNode && res.push(branchNode);\n  data.childNode && res.push(NodeFactory.call(ctx, ctx, data.childNode, h));\n  return res;\n}\n\nfunction addEndNode(h) {\n  return <section class=\"end-node\">流程结束</section>;\n}\n\nexport default {\n  props: {\n    data: { type: Object, required: true },\n    // 点击发布时需要校验节点数据完整性 此时打开校验模式\n    verifyMode: { type: Boolean, default: true },\n  },\n  watch: {\n\n  },\n  methods: {\n    /**\n     *事件触发器 统筹本组件所有事件并转发到父组件中\n     * @param { Object } 包含event（事件名）和args（事件参数）两个参数\n     */\n    eventLauncher(event, ...args) {\n      // args.slice(0,-1) vue 会注入MouseEvent到最后一个参数 去除事件对象\n      let param = { event, args: args.slice(0, -1) };\n      this.$emit(\"emits\", param);\n    }\n  },\n  render(h) {\n    return (\n      <div style=\"display: inline-flex; flex-direction: column; align-items: center;\">\n        {this.data && NodeFactory.call(this, this, this.data, h)}\n        {addEndNode(h)}\n      </div>\n    );\n  }\n};\n",null]}